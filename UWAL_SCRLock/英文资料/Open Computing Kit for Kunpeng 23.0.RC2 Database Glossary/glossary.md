# Glossary<a name="EN-US_TOPIC_0000001633143478"></a>

**Table  1**  Glossary

<a name="table0473173411118"></a>
<table><thead align="left"><tr id="row7474183471116"><th class="cellrowborder" valign="top" width="25%" id="mcps1.2.3.1.1"><p id="p5474183481117"><a name="p5474183481117"></a><a name="p5474183481117"></a>Term</p>
</th>
<th class="cellrowborder" valign="top" width="75%" id="mcps1.2.3.1.2"><p id="p1947412349110"><a name="p1947412349110"></a><a name="p1947412349110"></a>Definition</p>
</th>
</tr>
</thead>
<tbody><tr id="row1242471634011"><td class="cellrowborder" colspan="2" valign="top" headers="mcps1.2.3.1.1 mcps1.2.3.1.2 "><p id="p1561062318402"><a name="p1561062318402"></a><a name="p1561062318402"></a><strong id="b1032924919327"><a name="b1032924919327"></a><a name="b1032924919327"></a>A–E</strong></p>
</td>
</tr>
<tr id="row55701559701"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p05701459904"><a name="p05701459904"></a><a name="p05701459904"></a>CM</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p05705593019"><a name="p05705593019"></a><a name="p05705593019"></a>The cluster manager (CM) is a database management module. It supports customized resource monitoring and provides capabilities such as monitoring of the primary/standby database status, network communication faults, file system faults, and automatic primary/standby switchover upon faults. It also provides various database management capabilities, such as starting and stopping nodes and instances, querying database instance status, performing primary/standby switchover, and managing logs. The capability of remotely querying and receiving cluster status through REST interfaces is also provided.</p>
</td>
</tr>
<tr id="row19476234201112"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p42321652431"><a name="p42321652431"></a><a name="p42321652431"></a>DRAM</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p152327524313"><a name="p152327524313"></a><a name="p152327524313"></a>Dynamic random-access memory (DRAM) is the most common mode of computer storage. If a computer is powered off, all data stored in this mode will be lost. Therefore, this mode is not applicable to long-term data storage. DRAM highlights fast speed, which is faster than the flash memory and other non-dynamic storage media.</p>
</td>
</tr>
<tr id="row152831710124913"><td class="cellrowborder" colspan="2" valign="top" headers="mcps1.2.3.1.1 mcps1.2.3.1.2 "><p id="p417651814497"><a name="p417651814497"></a><a name="p417651814497"></a><strong id="b933203516544"><a name="b933203516544"></a><a name="b933203516544"></a>F–J</strong></p>
</td>
</tr>
<tr id="row74511334914"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p04541314915"><a name="p04541314915"></a><a name="p04541314915"></a>HCOM</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p134515135496"><a name="p134515135496"></a><a name="p134515135496"></a>High-performance communication component.</p>
</td>
</tr>
<tr id="row322165351816"><td class="cellrowborder" colspan="2" valign="top" headers="mcps1.2.3.1.1 mcps1.2.3.1.2 "><p id="p598384115307"><a name="p598384115307"></a><a name="p598384115307"></a><strong id="b23054359588"><a name="b23054359588"></a><a name="b23054359588"></a>K–O</strong></p>
</td>
</tr>
<tr id="row9727145631815"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p1872785681820"><a name="p1872785681820"></a><a name="p1872785681820"></a>NVMe</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p1072711564188"><a name="p1072711564188"></a><a name="p1072711564188"></a>Non-Volatile Memory express (NVMe) is a logical-device interface specification similar to AHCI and equivalent to the application layer in the communication protocol. It is used for accessing a computer's non-volatile storage media usually attached via PCI Express (PCIe) bus (e.g., SSDs with flash memory). The PCIe bus protocol is not necessarily required.</p>
</td>
</tr>
<tr id="row847065984010"><td class="cellrowborder" colspan="2" valign="top" headers="mcps1.2.3.1.1 mcps1.2.3.1.2 "><p id="p247035984011"><a name="p247035984011"></a><a name="p247035984011"></a><strong id="b10425165114581"><a name="b10425165114581"></a><a name="b10425165114581"></a>P–T</strong></p>
</td>
</tr>
<tr id="row1929055083217"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p223217521131"><a name="p223217521131"></a><a name="p223217521131"></a>RDMA</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p1746742103613"><a name="p1746742103613"></a><a name="p1746742103613"></a>Remote direct memory access (RDMA) is a technology that enables a computer to directly access the memory of another computer over a network. It allows the network adapter to directly access the application storage and supports zero-copy network communication.</p>
</td>
</tr>
<tr id="row514554416511"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p5145744957"><a name="p5145744957"></a><a name="p5145744957"></a>RPC</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p161459444513"><a name="p161459444513"></a><a name="p161459444513"></a>A remote procedure call (RPC) is a computer communication protocol that allows a computer program to cause a subroutine or procedure to execute in another address space (commonly on another computer on a shared network) without the programmer explicitly coding the details for this remote interaction. If the involved software uses object-oriented programming, a remote procedure call can be referred to as a remote call or remote method invocation (RMI), for example, Java RMI.</p>
</td>
</tr>
<tr id="row415161252811"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p615191272818"><a name="p615191272818"></a><a name="p615191272818"></a>SCRLock</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p3151161252812"><a name="p3151161252812"></a><a name="p3151161252812"></a>Smart-Cached Remote Lock (SCRLock) is a distributed lock SDK with local lock cache.</p>
</td>
</tr>
<tr id="row10339161213301"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p20339912123010"><a name="p20339912123010"></a><a name="p20339912123010"></a>TLS</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p933981233012"><a name="p933981233012"></a><a name="p933981233012"></a>Transport Layer Security (TLS) and its predecessor, Secure Sockets Layer (SSL), are cryptographic protocols that provide communications security over a computer network.</p>
</td>
</tr>
<tr id="row13877124915416"><td class="cellrowborder" colspan="2" valign="top" headers="mcps1.2.3.1.1 mcps1.2.3.1.2 "><p id="p142275313414"><a name="p142275313414"></a><a name="p142275313414"></a><strong id="b43318133598"><a name="b43318133598"></a><a name="b43318133598"></a>U–Z</strong></p>
</td>
</tr>
<tr id="row312755015467"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p223319521930"><a name="p223319521930"></a><a name="p223319521930"></a>UWAL</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p223375212313"><a name="p223375212313"></a><a name="p223375212313"></a>Unified Write-Ahead Log (UWAL) is a common component developed by Huawei. It is used to improve the performance of active/standby transaction submission as well as streaming replication and transmission.</p>
</td>
</tr>
<tr id="row1187115316469"><td class="cellrowborder" valign="top" width="25%" headers="mcps1.2.3.1.1 "><p id="p1323365212311"><a name="p1323365212311"></a><a name="p1323365212311"></a>WAL</p>
</td>
<td class="cellrowborder" valign="top" width="75%" headers="mcps1.2.3.1.2 "><p id="p823310521534"><a name="p823310521534"></a><a name="p823310521534"></a>Write-Ahead Log is a standard method to ensure data integrity. The core concept of WAL is that modifications to data files (storing tables and indexes) can be written only after these actions are logged, that is, after the log records describing these changes are flushed to persistent storage.</p>
</td>
</tr>
</tbody>
</table>

