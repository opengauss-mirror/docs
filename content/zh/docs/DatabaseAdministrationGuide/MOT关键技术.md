# MOT关键技术

MOT的关键技术如下：

-   内存优化数据结构：以实现高并发吞吐量和可预测的低延迟为目标，所有数据和索引都在内存中，不使用中间页缓冲区，并使用持续时间最短的锁。数据结构和所有算法都是专门为内存设计而优化的。
-   免锁事务管理：MOT在保证严格一致性和数据完整性的前提下，采用乐观的策略实现高并发和高吞吐。在事务过程中，MOT不会对正在更新的数据行的任何版本加锁，从而大大降低了一些大内存系统中的争用。事务中的乐观并发控制（Optimistic Concurrency Control，OCC）语句是在没有锁的情况下实现的，所有的数据修改都是在内存中专门用于私有事务的部分（也称为私有事务内存）中进行的。这就意味着在事务过程中，相关数据在私有事务内存中更新，从而实现了无锁读写；而且只有在提交阶段才会短时间加锁。更多详细信息，请参见[MOT并发控制机制](MOT并发控制机制.md)。
-   免锁索引：由于内存表的数据和索引完全存储在内存中，因此拥有一个高效的索引数据结构和算法非常重要。MOT索引机制基于最先进的Masstree，这是一种用于多核系统的快速和可扩展的键值（Key Value，KV）存储索引，以B+树的Trie实现。通过这种方式，高并发工作负载在多核服务器上可以获得卓越的性能。同时MOT应用了各种先进的技术以优化性能，如优化锁方法、高速缓存感知和内存预取。
-   NUMA-aware的内存管理：MOT内存访问的设计支持非统一内存访问（NUMA）感知。NUMA-aware算法增强了内存中数据布局的性能，使线程访问物理上连接到线程运行的核心的内存。这是由内存控制器处理的，不需要通过使用互连（如英特尔QPI）进行额外的跳转。MOT的智能内存控制模块，为各种内存对象预先分配了内存池，提高了性能，减少了锁，保证了稳定性。事务的内存对象的分配始终是NUMA本地的。本地处理的对象会返回到池中。同时在事务中尽量减少系统内存分配（OS malloc）的使用，避免不必要的锁。
-   高效持久性：日志和检查点是实现磁盘持久化的关键能力，也是ACID的关键要求之一（D代表持久性）。目前所有的磁盘（包括SSD和NVMe）都明显慢于内存，因此持久化是基于内存数据库引擎的瓶颈。作为一个基于内存的存储引擎，MOT的持久化设计必须实现各种各样的算法优化，以确保持久化的同时还能达到设计时的速度和吞吐量目标。这些优化包括：
    -   并行日志，所有openGauss磁盘表都支持。
    -   每个事务的日志缓冲和无锁事务准备。
    -   增量更新记录，即只记录变化。
    -   除了同步和异步之外，创新的NUMA感知组提交日志记录。
    -   最先进的数据库检查点（CALC）使内存和计算开销降到最低。

-   高SQL覆盖率和功能集：MOT通过扩展的PostgreSQL外部数据封装（FDW）以及索引，几乎支持完整的SQL范围，包括存储过程、用户定义函数和系统函数调用。有关不支持的功能的列表，请参阅[MOT SQL覆盖和限制](MOT-SQL覆盖和限制.md)。
-   使用PREPARE语句的查询原生编译：通过使用PREPARE客户端命令，可以以交互方式执行查询和事务语句。这些命令已被预编译成原生执行格式，也称为Code-Gen或即时（Just-in-Time，JIT）编译。这样可以实现平均30%的性能提升。在可能的情况下，应用编译和轻量级执行；否则，使用标准执行路径处理适用的查询。Cache Plan模块已针对OLTP进行了优化，在整个会话中甚至使用不同的绑定设置以及在不同的会话中重用编译结果。
-   JIT存储过程（JIT SP）：加快性能。JIT SP是指通过LLVM运行时代码生成和编译库来生成代码、编译和执行存储过程。JIT SP仅对访问MOT表的存储过程可用，对用户完全透明。加速级别取决于存储过程逻辑。例如，一个真实的客户应用程序为不同的存储过程实现了20%、44%、300%和500%的加速，减少了存储过程延迟。

-   无缝集成MVCC和跨引擎事务：MOT在集成封装中并排运行基于磁盘的（堆）存储引擎。在openGauss 5.0版本中，MOT支持MVCC和跨引擎事务，以及堆和MOT表之间的连接。

