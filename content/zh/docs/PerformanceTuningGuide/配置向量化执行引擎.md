# 向量化引擎

## 可获得性<a name="section3480125215575"></a>

本特性自openGauss 1.0.0版本开始引入。

## 特性简介<a name="section5814521587"></a>

openGauss提供向量化引擎，通常用在OLAP数据仓库类系统。主要是因为分析型系统通常是数据处理密集型，基本上都是采用顺序方式来访问表中大部分的数据，然后再进行计算，最后将计算结果输出给用户。

## 客户价值<a name="section148987345811"></a>

通过批量计算，大幅提高复杂类查询性能。

## 特性描述<a name="section117041846581"></a>

传统的数据库查询执行都是采用一次一数组（tuple）的pipeline执行模式，因此CPU的大部分处理时间不是用来处理数据，而是遍历查询操作树。这种情况下CPU的有效利用率不高，同时也会导致低指令缓存性能和频繁跳转。更加糟糕的是，这种方式的执行，不能够利用现代硬件的新优化特征来加速查询的执行。在执行引擎中，另外一个解决方案就是改变一次一数组（tuple）为一次一列的模式。这也是我们向量化执行引擎的一个基础。

向量化引擎是跟列存储技术绑定的，因为列存储时每列数据存储在一起，可以认为这些数据是以数组的方式存储的。基于这样的特征，当该列数据需要进行某一同样操作，可以通过一个循环来高效完成对这个数据块各个值的计算。

向量化执行引擎的优势在于：

- 可以减少节点间的调度，提高CPU的利用率。
- 因为相同类型的数据放在一起，可以更容易的利用硬件与编译的新优化特征。

## 依赖关系<a name="section20491151513592"></a>

依赖于[列存储](../BriefTutorial/列存储.md)。

## 配置向量化执行引擎

openGauss数据库支持行执行引擎和向量化执行引擎，分别对应行存表和列存表。

- 一次一个batch，读取更多数据，节省IO。
- batch中记录较多，CPU cache命中率提升。
- Pipeline模式执行，函数调用次数少。
- 一次处理一批数据，效率高。

openGauss数据库所以对于分析类的复杂查询能够获得更好的查询性能。但列存表在数据插入和数据更新上表现不佳，对于存在数据频繁插入和更新的业务无法使用列存表。

为了提升行存表在分析类的复杂查询上的查询性能，openGauss数据库提供行存表使用向量化执行引擎的能力。通过设置GUC参数[try\_vector\_engine\_strategy](../DatabaseReference/优化器方法配置.md)，可以将包含行存表的查询语句转换为向量化执行计划执行。

行存表转换为向量化执行引擎执行不是对所有的查询场景都适用。参考向量化引擎的优势，如果查询语句中包含表达式计算、多表join、聚集等操作时，通过转换为向量化执行能够获得性能提升。从原理上分析，行存表转换为向量化执行，会产生转换的开销，导致性能下降。而上述操作的表达式计算、join操作、聚集操作转换为向量化执行之后，能够获得获得性能提升。所以查询转换为向量化执行后，性能是否提升，取决于查询转换为向量化之后获得的性能提升能否高于转换产生的性能开销。

以TPCH Q1为例，使用行执行引擎时，扫描算子的执行时间为405210ms，聚集操作的执行时间为2618964ms；而转换为向量化执行引擎后，扫描算子（SeqScan + VectorAdapter）的执行时间为470840ms，聚集操作的执行时间为212384ms，所以查询能够获得性能提升。

TPCH Q1 行执行引擎执行计划：

```sql
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=43539570.49..43539570.50 rows=6 width=260) (actual time=3024174.439..3024174.439 rows=4 loops=1)
   Sort Key: l_returnflag, l_linestatus
   Sort Method: quicksort  Memory: 25kB
   ->  HashAggregate  (cost=43539570.30..43539570.41 rows=6 width=260) (actual time=3024174.396..3024174.403 rows=4 loops=1)
         Group By Key: l_returnflag, l_linestatus
         ->  Seq Scan on lineitem  (cost=0.00..19904554.46 rows=590875396 width=28) (actual time=0.016..405210.038 rows=596140342 loops=1)
               Filter: (l_shipdate <= '1998-10-01 00:00:00'::timestamp without time zone)
               Rows Removed by Filter: 3897560
 Total runtime: 3024174.578 ms
(9 rows)
```

TPCH Q1 向量化执行引擎执行计划：

```sql
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter  (cost=43825808.18..43825808.18 rows=6 width=298) (actual time=683224.925..683224.927 rows=4 loops=1)
   ->  Vector Sort  (cost=43825808.16..43825808.18 rows=6 width=298) (actual time=683224.919..683224.919 rows=4 loops=1)
         Sort Key: l_returnflag, l_linestatus
         Sort Method: quicksort  Memory: 3kB
         ->  Vector Sonic Hash Aggregate  (cost=43825807.98..43825808.08 rows=6 width=298) (actual time=683224.837..683224.837 rows=4 loops=1)
               Group By Key: l_returnflag, l_linestatus
               ->  Vector Adapter(type: BATCH MODE)  (cost=19966853.54..19966853.54 rows=596473861 width=66) (actual time=0.982..470840.274 rows=596140342 loops=1)
                     Filter: (l_shipdate <= '1998-10-01 00:00:00'::timestamp without time zone)
                     Rows Removed by Filter: 3897560
                     ->  Seq Scan on lineitem  (cost=0.00..19966853.54 rows=596473861 width=66) (actual time=0.364..199301.737 rows=600037902 loops=1)
 Total runtime: 683225.564 ms
(11 rows)
```
