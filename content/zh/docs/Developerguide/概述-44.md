# 概述

DeepSQL是对openGauss DB4AI能力的增强，让对MADLib比较熟悉的数据分析师或开发者可以轻松迁移到openGauss上进行工作。DeepSQL将常用的机器学习算法封装为SQL语句，支持60多个常用算法。其中包括回归算法（例如线性回归、逻辑回归、随机森林等）、分类算法（比如KNN等）、聚类算法（比如K-means）等。除了基础的机器学习算法之外，还包括图相关的算法，比如最短路径、图形直径等算法；此外还支持数据处理（比如PCA）、稀疏向量、统计学常用算法（比如协方差、Pearson系数计算等）、训练集测试集分割方法、交叉验证方法等。

**表 1**  支持的机器学习算法 - 回归类算法

<a name="table1794330112214"></a>
<table><thead align="left"><tr id="row1494103011222"><th class="cellrowborder" valign="top" width="10.63%" id="mcps1.2.4.1.1"><p id="p169553092218"><a name="p169553092218"></a><a name="p169553092218"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="17.31%" id="mcps1.2.4.1.2"><p id="p39583014222"><a name="p39583014222"></a><a name="p39583014222"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="72.06%" id="mcps1.2.4.1.3"><p id="p795143042218"><a name="p795143042218"></a><a name="p795143042218"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row129512301228"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p169593017220"><a name="p169593017220"></a><a name="p169593017220"></a>逻辑回归</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p1295123062219"><a name="p1295123062219"></a><a name="p1295123062219"></a>Logistic Regression</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p12106913288"><a name="p12106913288"></a><a name="p12106913288"></a>例如寻找某疾病的危险因素，金融商业机构需要对企业进行评估等。</p>
<p id="p1471750153017"><a name="p1471750153017"></a><a name="p1471750153017"></a>预测：根据模型预测不同的自变量情况下某病或某情况的发生概率。</p>
<p id="p11101797280"><a name="p11101797280"></a><a name="p11101797280"></a>判别：实际上跟预测类似，也是根据模型判断某人属于某病或属于某种情况的概率有多大，即判断某人有多大可能是属于某病。</p>
</td>
</tr>
<tr id="row19954304220"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p199517305227"><a name="p199517305227"></a><a name="p199517305227"></a>Cox比例风险回归</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p5959307228"><a name="p5959307228"></a><a name="p5959307228"></a>Cox Proportional Hazards Regression</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p1395143015227"><a name="p1395143015227"></a><a name="p1395143015227"></a>该模型以生存结局和生存时间为因变量，可同时分析众多因素对生存期的影响，能分析带有截尾生存时间的资料，且不要求估计资料的生存分布类型。由于上述优良性质，该模型自问世以来，在医学类研究中得到广泛的应用，是迄今生存分析中应用最多的多因素分析方法。</p>
</td>
</tr>
<tr id="row19950302221"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p49543032219"><a name="p49543032219"></a><a name="p49543032219"></a>弹性网络回归</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p595163022218"><a name="p595163022218"></a><a name="p595163022218"></a>Elastic Net Regularization</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p49520308229"><a name="p49520308229"></a><a name="p49520308229"></a>弹性回归是岭回归和套索回归的混合技术，它同时使用 L2 和 L1 正则化。当有多个相关的特征时，套索回归很可能随机选择其中一个，而弹性回归很可能都会选择。</p>
</td>
</tr>
<tr id="row99643082210"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p2964306229"><a name="p2964306229"></a><a name="p2964306229"></a>广义线性模型</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p189633042214"><a name="p189633042214"></a><a name="p189633042214"></a>Generalized Linear Models</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p14961730122210"><a name="p14961730122210"></a><a name="p14961730122210"></a>在一些实际问题中，变量间的关系并不都是线性的，这种情况就应该用曲线去进行拟合。</p>
</td>
</tr>
<tr id="row696630162212"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p2962306221"><a name="p2962306221"></a><a name="p2962306221"></a>边际效应</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p296143022217"><a name="p296143022217"></a><a name="p296143022217"></a>Marginal Effects</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p1496153019227"><a name="p1496153019227"></a><a name="p1496153019227"></a>提供边际效应的计算。</p>
</td>
</tr>
<tr id="row209683011222"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p9961130152214"><a name="p9961130152214"></a><a name="p9961130152214"></a>多类回归</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p1896730102219"><a name="p1896730102219"></a><a name="p1896730102219"></a>Multinomial Regression</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p296133011221"><a name="p296133011221"></a><a name="p296133011221"></a>如果目标类别数超过两个，这时就需要使用多类回归，如疗效可能是“无效”、“显效”、“痊愈”三类。</p>
</td>
</tr>
<tr id="row1296193022217"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p1296113022217"><a name="p1296113022217"></a><a name="p1296113022217"></a>序数回归</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p7969307224"><a name="p7969307224"></a><a name="p7969307224"></a>Ordinal Regression</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p59743019228"><a name="p59743019228"></a><a name="p59743019228"></a>在统计学中，序数回归是一种用于预测序数变量的回归分析，即其值存在于任意范围内的变量，不同值之间的度量距离也不同。它可以被认为是介于回归和分类之间的一类问题。例如，病情的分级（1、2、3、4级），症状的感觉分级（不痛、微痛、较痛和剧痛），对药物剂量反应的分级（无效、微效、中效和高效）等等。不同级别之间的差异不一定相等，如不痛与微痛的差值不一定等于较痛与剧痛的差值。</p>
</td>
</tr>
<tr id="row1175543110251"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p197565312259"><a name="p197565312259"></a><a name="p197565312259"></a>聚类方差</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p475618318256"><a name="p475618318256"></a><a name="p475618318256"></a>Clustered Variance</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p1175673162515"><a name="p1175673162515"></a><a name="p1175673162515"></a>Clustered Variance模块调整聚类的标准误差。例如，将一个数据集合复制100次，不应该增加参数估计的精度，但是在符合独立同分布假设（Independent Identically Distributed，IID）下执行这个过程实际上会提高精度。</p>
</td>
</tr>
<tr id="row184031335122518"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p1540483514253"><a name="p1540483514253"></a><a name="p1540483514253"></a>稳健方差</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p194046356251"><a name="p194046356251"></a><a name="p194046356251"></a>Robust Variance</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p24041635122515"><a name="p24041635122515"></a><a name="p24041635122515"></a>Robust Variance模块中的函数用于计算线性回归、逻辑回归、多类逻辑回归和Cox比例风险回归的稳健方差（Huber-White估计）。它们可用于计算具有潜在噪声异常值的数据集中数据的差异。</p>
</td>
</tr>
<tr id="row1293444012256"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p1993516408256"><a name="p1993516408256"></a><a name="p1993516408256"></a>支持向量机</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p8935540142519"><a name="p8935540142519"></a><a name="p8935540142519"></a>Support Vector Machines(SVM)</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p29631481307"><a name="p29631481307"></a><a name="p29631481307"></a>用于文本和超文本的分类、图像分类，比起传统的查询优化方案，支持向量机能够获取明显更高的搜索准确度。这同样也适用于图像分割系统。</p>
</td>
</tr>
<tr id="row13892174622516"><td class="cellrowborder" valign="top" width="10.63%" headers="mcps1.2.4.1.1 "><p id="p889284610252"><a name="p889284610252"></a><a name="p889284610252"></a>线性回归</p>
</td>
<td class="cellrowborder" valign="top" width="17.31%" headers="mcps1.2.4.1.2 "><p id="p889215469259"><a name="p889215469259"></a><a name="p889215469259"></a>Linear Regression</p>
</td>
<td class="cellrowborder" valign="top" width="72.06%" headers="mcps1.2.4.1.3 "><p id="p1889294692517"><a name="p1889294692517"></a><a name="p1889294692517"></a>应用广泛，例如经济学、金融学等。</p>
</td>
</tr>
</tbody>
</table>

**表 2**  支持的机器学习算法 - 其他监督学习

<a name="table185531692118"></a>
<table><thead align="left"><tr id="row8553560216"><th class="cellrowborder" valign="top" width="10.83108310831083%" id="mcps1.2.4.1.1"><p id="p364762072111"><a name="p364762072111"></a><a name="p364762072111"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="16.84168416841684%" id="mcps1.2.4.1.2"><p id="p764772052117"><a name="p764772052117"></a><a name="p764772052117"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="72.32723272327232%" id="mcps1.2.4.1.3"><p id="p1664702092111"><a name="p1664702092111"></a><a name="p1664702092111"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row145532692113"><td class="cellrowborder" valign="top" width="10.83108310831083%" headers="mcps1.2.4.1.1 "><p id="p7553664212"><a name="p7553664212"></a><a name="p7553664212"></a>决策树</p>
</td>
<td class="cellrowborder" valign="top" width="16.84168416841684%" headers="mcps1.2.4.1.2 "><p id="p2055318652113"><a name="p2055318652113"></a><a name="p2055318652113"></a>Decision Tree</p>
</td>
<td class="cellrowborder" valign="top" width="72.32723272327232%" headers="mcps1.2.4.1.3 "><p id="p0553126132113"><a name="p0553126132113"></a><a name="p0553126132113"></a>最为广泛的归纳推理算法之一，处理类别型或连续型变量的分类预测问题，可以用图形和if-then的规则表示模型，可读性较高。</p>
</td>
</tr>
<tr id="row185532612214"><td class="cellrowborder" valign="top" width="10.83108310831083%" headers="mcps1.2.4.1.1 "><p id="p65531469212"><a name="p65531469212"></a><a name="p65531469212"></a>随机森林</p>
</td>
<td class="cellrowborder" valign="top" width="16.84168416841684%" headers="mcps1.2.4.1.2 "><p id="p35531363219"><a name="p35531363219"></a><a name="p35531363219"></a>Random Forest</p>
</td>
<td class="cellrowborder" valign="top" width="72.32723272327232%" headers="mcps1.2.4.1.3 "><p id="p45531766218"><a name="p45531766218"></a><a name="p45531766218"></a>随机森林是一类专门为决策树分类器设计的组合方法。它组合多棵决策树作出的预测。</p>
</td>
</tr>
<tr id="row115546662119"><td class="cellrowborder" valign="top" width="10.83108310831083%" headers="mcps1.2.4.1.1 "><p id="p55541682116"><a name="p55541682116"></a><a name="p55541682116"></a>条件随机场</p>
</td>
<td class="cellrowborder" valign="top" width="16.84168416841684%" headers="mcps1.2.4.1.2 "><p id="p1655416112114"><a name="p1655416112114"></a><a name="p1655416112114"></a>Conditional Random Field (CRF)</p>
</td>
<td class="cellrowborder" valign="top" width="72.32723272327232%" headers="mcps1.2.4.1.3 "><p id="p1555416617212"><a name="p1555416617212"></a><a name="p1555416617212"></a>条件随机场（CRF）是一种判别的、无向概率的图形模型。线性链CRF是一种特殊类型的CRF，它假定当前状态仅取决于先前的状态。在分词、词性标注和命名实体识别等序列标注任务中取得了很好的效果。</p>
</td>
</tr>
<tr id="row7554166102116"><td class="cellrowborder" valign="top" width="10.83108310831083%" headers="mcps1.2.4.1.1 "><p id="p125541769218"><a name="p125541769218"></a><a name="p125541769218"></a>朴素贝叶斯</p>
</td>
<td class="cellrowborder" valign="top" width="16.84168416841684%" headers="mcps1.2.4.1.2 "><p id="p1055486132118"><a name="p1055486132118"></a><a name="p1055486132118"></a>Naive Bayes</p>
</td>
<td class="cellrowborder" valign="top" width="72.32723272327232%" headers="mcps1.2.4.1.3 "><p id="p55547617215"><a name="p55547617215"></a><a name="p55547617215"></a>通过计算概率来进行分类，可以用来处理多分类问题，比如：垃圾邮件过滤器。</p>
</td>
</tr>
<tr id="row1554561212"><td class="cellrowborder" valign="top" width="10.83108310831083%" headers="mcps1.2.4.1.1 "><p id="p2554136142117"><a name="p2554136142117"></a><a name="p2554136142117"></a>神经网络</p>
</td>
<td class="cellrowborder" valign="top" width="16.84168416841684%" headers="mcps1.2.4.1.2 "><p id="p195549692118"><a name="p195549692118"></a><a name="p195549692118"></a>Neural Networks</p>
</td>
<td class="cellrowborder" valign="top" width="72.32723272327232%" headers="mcps1.2.4.1.3 "><p id="p1855419632112"><a name="p1855419632112"></a><a name="p1855419632112"></a>拥有广泛的应用场景，譬如语音识别、图像识别、机器翻译等等。在模式识别的领域中算是标准监督学习算法，并在计算神经学中，持续成为被研究的课题。MLP已被证明是一种通用的函数近似方法，可以被用来拟合复杂的函数或解决分类问题。</p>
</td>
</tr>
<tr id="row10554186202111"><td class="cellrowborder" valign="top" width="10.83108310831083%" headers="mcps1.2.4.1.1 "><p id="p185546682110"><a name="p185546682110"></a><a name="p185546682110"></a>k临近算法</p>
</td>
<td class="cellrowborder" valign="top" width="16.84168416841684%" headers="mcps1.2.4.1.2 "><p id="p955411672118"><a name="p955411672118"></a><a name="p955411672118"></a>k-Nearest Neighbors</p>
</td>
<td class="cellrowborder" valign="top" width="72.32723272327232%" headers="mcps1.2.4.1.3 "><p id="p16649165416515"><a name="p16649165416515"></a><a name="p16649165416515"></a>K近邻分类方法通过计算每个训练样例到待分类样品的距离，取和待分类样品距离最近的K个训练样例，K个样品中哪个类别的训练样例占多数，则待分类元组就属于哪个类别。</p>
<p id="p1655476152119"><a name="p1655476152119"></a><a name="p1655476152119"></a>可用于：文字识别、面部识别、基因模式识别、客户流失预测、欺诈侦测。</p>
</td>
</tr>
</tbody>
</table>

**表 3**  支持的机器学习算法 - 数据处理类算法

<a name="table89836408312"></a>
<table><thead align="left"><tr id="row14983174033118"><th class="cellrowborder" valign="top" width="10.04100410041004%" id="mcps1.2.4.1.1"><p id="p1528823212322"><a name="p1528823212322"></a><a name="p1528823212322"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="18.531853185318532%" id="mcps1.2.4.1.2"><p id="p8288183233219"><a name="p8288183233219"></a><a name="p8288183233219"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="71.42714271427141%" id="mcps1.2.4.1.3"><p id="p1528833233211"><a name="p1528833233211"></a><a name="p1528833233211"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row15983144033117"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p14984164013110"><a name="p14984164013110"></a><a name="p14984164013110"></a>数组操作</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p1498412404315"><a name="p1498412404315"></a><a name="p1498412404315"></a>Array Operations</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p3156332123714"><a name="p3156332123714"></a><a name="p3156332123714"></a>数组、向量操作运算，包括基础的加减乘除、幂运算、开方、cos、sin、绝对值、方差等。</p>
</td>
</tr>
<tr id="row1698419401319"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p1760602703311"><a name="p1760602703311"></a><a name="p1760602703311"></a>主成成分分析</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p132357253332"><a name="p132357253332"></a><a name="p132357253332"></a>Dimensionality Reduction (PCA)</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p2098413406315"><a name="p2098413406315"></a><a name="p2098413406315"></a>降维，计算主成分。</p>
</td>
</tr>
<tr id="row1998424015319"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p8984114043118"><a name="p8984114043118"></a><a name="p8984114043118"></a>变量编码</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p79841740183110"><a name="p79841740183110"></a><a name="p79841740183110"></a>Encoding Categorical Variables</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p64018265314"><a name="p64018265314"></a><a name="p64018265314"></a>当前支持one-hot和dummy编码技术。</p>
<p id="p815911224375"><a name="p815911224375"></a><a name="p815911224375"></a>当需要用一组特定的预测变量与其它预测变量组作比较时，通常使用哑编码（dummy coding），与之比较的变量组称为参照组。One-hot编码与哑编码类似，两者的区别是前者为每种分类值建立数字类型的0/1指示列。在每行数据中（对应一个数据点），只有一个分类编码列的值可以为1。</p>
</td>
</tr>
<tr id="row8984124012314"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p1698434014311"><a name="p1698434014311"></a><a name="p1698434014311"></a>矩阵操作</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p498414403313"><a name="p498414403313"></a><a name="p498414403313"></a>Matrix Operations</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p117551051388"><a name="p117551051388"></a><a name="p117551051388"></a>运用矩阵分解，将大型矩阵分解成简单矩阵的乘积形式，则可大大降低计算的难度以及计算量。</p>
<p id="p8984194016313"><a name="p8984194016313"></a><a name="p8984194016313"></a>矩阵加减乘除、最值、均值、求秩、求逆、矩阵分解（QR、LU、Cholesky），特征提取。</p>
</td>
</tr>
<tr id="row169845404312"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p8984154012311"><a name="p8984154012311"></a><a name="p8984154012311"></a>规范化和距离函数</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p7984104011317"><a name="p7984104011317"></a><a name="p7984104011317"></a>Norms and Distance Functions</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p898434083114"><a name="p898434083114"></a><a name="p898434083114"></a>求范数、余弦相似度、向量间距离。</p>
</td>
</tr>
<tr id="row798484016316"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p29841540163116"><a name="p29841540163116"></a><a name="p29841540163116"></a>稀疏向量</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p998417403315"><a name="p998417403315"></a><a name="p998417403315"></a>Sparse Vectors</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p2984740173113"><a name="p2984740173113"></a><a name="p2984740173113"></a>实现稀疏向量类型，如果向量中重复值较多，可以用来压缩储存节省空间。</p>
</td>
</tr>
<tr id="row10608101717341"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p16609517123412"><a name="p16609517123412"></a><a name="p16609517123412"></a>透视图</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p11609161763412"><a name="p11609161763412"></a><a name="p11609161763412"></a>Pivot</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p360912171342"><a name="p360912171342"></a><a name="p360912171342"></a>透视表或枢轴表，通常用来实现OLAP或报表系统中一类常见的行列转置需求。pivot函数能够对一个表中存储的数据执行基本行转列操作，并将汇总后的结果输出到另一个表中。使行列转置操作变得更为简单与灵活。</p>
</td>
</tr>
<tr id="row1329632115341"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p12296821193415"><a name="p12296821193415"></a><a name="p12296821193415"></a>模式匹配</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p18296192123413"><a name="p18296192123413"></a><a name="p18296192123413"></a>Path</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p14296152120348"><a name="p14296152120348"></a><a name="p14296152120348"></a>是在一系列行上执行常规模式匹配，并提取有关模式匹配的有用信息。有用的信息可以是简单的匹配计数或更多涉及的内容，如聚合或窗口函数。</p>
</td>
</tr>
<tr id="row151090259343"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p131102025113418"><a name="p131102025113418"></a><a name="p131102025113418"></a>会话</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p1111052583410"><a name="p1111052583410"></a><a name="p1111052583410"></a>Sessionize</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p18110172514343"><a name="p18110172514343"></a><a name="p18110172514343"></a>会话化功能对包括事件序列的数据集执行面向时间的会话重建。定义的不活动时段表示一个会话的结束和下一个会话的开始。</p>
<p id="p515116125361"><a name="p515116125361"></a><a name="p515116125361"></a>可以用于：网络分析、网络安全、制造、财务和运营分析。</p>
</td>
</tr>
<tr id="row2093316281346"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p1493382812344"><a name="p1493382812344"></a><a name="p1493382812344"></a>共轭梯度法</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p17933128143417"><a name="p17933128143417"></a><a name="p17933128143417"></a>Conjugate gradient</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p1693316288345"><a name="p1693316288345"></a><a name="p1693316288345"></a>求解系数矩阵为对称正定矩阵的线性方程组的数值解的方法。</p>
</td>
</tr>
<tr id="row1729361183519"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p1429371115353"><a name="p1429371115353"></a><a name="p1429371115353"></a>词干提取</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p1129311115354"><a name="p1129311115354"></a><a name="p1129311115354"></a>Stemming</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p19162185615359"><a name="p19162185615359"></a><a name="p19162185615359"></a>词干提取简单说就是找出单词中的词干部分，场景比如：搜索引擎建立网页主题概念。</p>
<p id="p71621256143516"><a name="p71621256143516"></a><a name="p71621256143516"></a>在英文网站优化作用明显，对其他语言有借鉴意义。</p>
</td>
</tr>
<tr id="row1682012617407"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p14820726134013"><a name="p14820726134013"></a><a name="p14820726134013"></a>训练集测试集分割</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p17820182694013"><a name="p17820182694013"></a><a name="p17820182694013"></a>Train-Test Split</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p4820626184014"><a name="p4820626184014"></a><a name="p4820626184014"></a>分割数据集，把一份数据集划分成训练集和测试集，train的部分用于训练，test部分用于验证。</p>
</td>
</tr>
<tr id="row234813317406"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p123485338405"><a name="p123485338405"></a><a name="p123485338405"></a>交叉验证</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p63481336407"><a name="p63481336407"></a><a name="p63481336407"></a>Cross Validation</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p53485334407"><a name="p53485334407"></a><a name="p53485334407"></a>交叉验证。</p>
</td>
</tr>
<tr id="row33451640204013"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p19345124024014"><a name="p19345124024014"></a><a name="p19345124024014"></a>预测指标</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p93456402401"><a name="p93456402401"></a><a name="p93456402401"></a>Prediction Metrics</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p53451240114016"><a name="p53451240114016"></a><a name="p53451240114016"></a>用于评估模型预测的质量，包括均方误差、AUC值、混淆矩阵、修正R方等用于评价模型的函数。</p>
</td>
</tr>
<tr id="row161046303404"><td class="cellrowborder" valign="top" width="10.04100410041004%" headers="mcps1.2.4.1.1 "><p id="p51051930144010"><a name="p51051930144010"></a><a name="p51051930144010"></a>小批量预处理</p>
</td>
<td class="cellrowborder" valign="top" width="18.531853185318532%" headers="mcps1.2.4.1.2 "><p id="p310512304406"><a name="p310512304406"></a><a name="p310512304406"></a>Mini-Batch Preprocessor</p>
</td>
<td class="cellrowborder" valign="top" width="71.42714271427141%" headers="mcps1.2.4.1.3 "><p id="p81054304400"><a name="p81054304400"></a><a name="p81054304400"></a>把数据打包成小份进行训练，优点是它可以比随机梯度下降（默认MADlib优化器）表现更好，会更快更平滑的收敛。</p>
</td>
</tr>
</tbody>
</table>

**表 4**  支持的机器学习算法 - 图类

<a name="table153361051113913"></a>
<table><thead align="left"><tr id="row12336195118399"><th class="cellrowborder" valign="top" width="10.501050105010501%" id="mcps1.2.4.1.1"><p id="p1393095814413"><a name="p1393095814413"></a><a name="p1393095814413"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="17.9017901790179%" id="mcps1.2.4.1.2"><p id="p993095816416"><a name="p993095816416"></a><a name="p993095816416"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="71.59715971597159%" id="mcps1.2.4.1.3"><p id="p49301758104113"><a name="p49301758104113"></a><a name="p49301758104113"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row433795114393"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p14337185113910"><a name="p14337185113910"></a><a name="p14337185113910"></a>所有对间最短路径</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p43377511396"><a name="p43377511396"></a><a name="p43377511396"></a>All Pairs Shortest Path (APSP)</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p233710512394"><a name="p233710512394"></a><a name="p233710512394"></a>所有对最短路径（APSP）算法找到所有顶点对之间的最短路径的长度（总和权重），使得路径边缘的权重之和最小化。</p>
</td>
</tr>
<tr id="row43378512398"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p1333711516395"><a name="p1333711516395"></a><a name="p1333711516395"></a>广度优先算法</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p163371951143912"><a name="p163371951143912"></a><a name="p163371951143912"></a>Breadth-First Search</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p9337165113399"><a name="p9337165113399"></a><a name="p9337165113399"></a>广度优先算法遍历路径。</p>
</td>
</tr>
<tr id="row1733745163920"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p3337351193911"><a name="p3337351193911"></a><a name="p3337351193911"></a>超链接诱导主题搜索</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p10337651203911"><a name="p10337651203911"></a><a name="p10337651203911"></a>Hyperlink-Induced Topic Search (HITS)</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p8337951133920"><a name="p8337951133920"></a><a name="p8337951133920"></a>HITS算法输出每个节点的authority评分和hub评分，其中authority评分给出页面内容的分数，hub评估出连接到其他页面的分数。</p>
</td>
</tr>
<tr id="row233795111392"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p63371519398"><a name="p63371519398"></a><a name="p63371519398"></a>平均路径长度</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p193372051143919"><a name="p193372051143919"></a><a name="p193372051143919"></a>Average Path Length</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p153379516399"><a name="p153379516399"></a><a name="p153379516399"></a>此函数计算每对顶点之间的最短路径的平均值。平均路径长度基于“可到达的目标顶点”，因此它忽略了未连接的顶点之间的无限长度路径。</p>
</td>
</tr>
<tr id="row33377515395"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p1033745193918"><a name="p1033745193918"></a><a name="p1033745193918"></a>中心性</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p033795133914"><a name="p033795133914"></a><a name="p033795133914"></a>Closeness Centrality</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p4337125119393"><a name="p4337125119393"></a><a name="p4337125119393"></a>接近度度量是和的倒数，平均值的倒数，以及到所有可到达目标顶点（不包括源顶点）的最短距离的倒数之和。</p>
</td>
</tr>
<tr id="row1434018144313"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p934011113439"><a name="p934011113439"></a><a name="p934011113439"></a>图表直径</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p16340517432"><a name="p16340517432"></a><a name="p16340517432"></a>Graph Diameter</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p234051174318"><a name="p234051174318"></a><a name="p234051174318"></a>直径被定义为图中所有最短路径中最长的。</p>
</td>
</tr>
<tr id="row431674134313"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p13164414431"><a name="p13164414431"></a><a name="p13164414431"></a>入度出度</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p13316443433"><a name="p13316443433"></a><a name="p13316443433"></a>In-Out Degree</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p531684154317"><a name="p531684154317"></a><a name="p531684154317"></a>计算图中每个点的入度出度，入度指指向此点的边的数量，出度指此点指向其他点的边的数量。</p>
</td>
</tr>
<tr id="row177383615431"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p127383684315"><a name="p127383684315"></a><a name="p127383684315"></a>网页排名</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p1673846154317"><a name="p1673846154317"></a><a name="p1673846154317"></a>PageRank</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p37386624320"><a name="p37386624320"></a><a name="p37386624320"></a>给定图形，PageRank算法输出概率分布，该概率分布表示随机遍历图形的人将到达任何特定顶点的可能性。</p>
</td>
</tr>
<tr id="row18338199184312"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p153383934313"><a name="p153383934313"></a><a name="p153383934313"></a>单源最短路径</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p133386924310"><a name="p133386924310"></a><a name="p133386924310"></a>Single Source Shortest Path (SSSP)</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p14392818165112"><a name="p14392818165112"></a><a name="p14392818165112"></a>给定图形和源顶点，单源最短路径（SSSP）算法找到从源顶点到图中的每个其他顶点的路径，使得路径边缘的权重之和最小化（每条边权值非负）。</p>
</td>
</tr>
<tr id="row1412412204314"><td class="cellrowborder" valign="top" width="10.501050105010501%" headers="mcps1.2.4.1.1 "><p id="p5126126438"><a name="p5126126438"></a><a name="p5126126438"></a>弱连通分量</p>
</td>
<td class="cellrowborder" valign="top" width="17.9017901790179%" headers="mcps1.2.4.1.2 "><p id="p18121412114313"><a name="p18121412114313"></a><a name="p18121412114313"></a>Weakly Connected Component</p>
</td>
<td class="cellrowborder" valign="top" width="71.59715971597159%" headers="mcps1.2.4.1.3 "><p id="p1712161234314"><a name="p1712161234314"></a><a name="p1712161234314"></a>给定有向图，弱连通分量（WCC）是原始图的子图，其中所有顶点通过某个路径彼此连接，忽略边的方向。在无向图的情况下，弱连通分量也是强连通分量。该模块还包括许多在WCC输出上运行的辅助函数。</p>
</td>
</tr>
</tbody>
</table>

**表 5**  支持的机器学习算法 - 时间序列

<a name="table10752114512562"></a>
<table><thead align="left"><tr id="row9752114535615"><th class="cellrowborder" valign="top" width="21.602160216021602%" id="mcps1.2.4.1.1"><p id="p4752204515617"><a name="p4752204515617"></a><a name="p4752204515617"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="34.283428342834284%" id="mcps1.2.4.1.2"><p id="p1675274512569"><a name="p1675274512569"></a><a name="p1675274512569"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="44.114411441144114%" id="mcps1.2.4.1.3"><p id="p18752174515617"><a name="p18752174515617"></a><a name="p18752174515617"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row15752045115610"><td class="cellrowborder" valign="top" width="21.602160216021602%" headers="mcps1.2.4.1.1 "><p id="p187521845145611"><a name="p187521845145611"></a><a name="p187521845145611"></a>差分整合移动平均自回归模型</p>
</td>
<td class="cellrowborder" valign="top" width="34.283428342834284%" headers="mcps1.2.4.1.2 "><p id="p187521845175611"><a name="p187521845175611"></a><a name="p187521845175611"></a>Autoregressive Integrated Moving Average model(ARIMA)</p>
</td>
<td class="cellrowborder" valign="top" width="44.114411441144114%" headers="mcps1.2.4.1.3 "><p id="p18752114512568"><a name="p18752114512568"></a><a name="p18752114512568"></a>时间序列预测，用于理解和预测一系列数据的未来值。</p>
<p id="p4810153919572"><a name="p4810153919572"></a><a name="p4810153919572"></a>比如：国际航空旅客数据、预测旅客人数。</p>
</td>
</tr>
</tbody>
</table>

**表 6**  支持的机器学习算法 - 采样

<a name="table4800126141316"></a>
<table><thead align="left"><tr id="row780092601311"><th class="cellrowborder" valign="top" width="17.141714171417142%" id="mcps1.2.4.1.1"><p id="p270284991312"><a name="p270284991312"></a><a name="p270284991312"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="21.632163216321633%" id="mcps1.2.4.1.2"><p id="p970204991315"><a name="p970204991315"></a><a name="p970204991315"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="61.22612261226122%" id="mcps1.2.4.1.3"><p id="p1870220498133"><a name="p1870220498133"></a><a name="p1870220498133"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row58001226111315"><td class="cellrowborder" valign="top" width="17.141714171417142%" headers="mcps1.2.4.1.1 "><p id="p4800426101312"><a name="p4800426101312"></a><a name="p4800426101312"></a>采样函数</p>
</td>
<td class="cellrowborder" valign="top" width="21.632163216321633%" headers="mcps1.2.4.1.2 "><p id="p380042671315"><a name="p380042671315"></a><a name="p380042671315"></a>sample</p>
</td>
<td class="cellrowborder" valign="top" width="61.22612261226122%" headers="mcps1.2.4.1.3 "><p id="p1780012264134"><a name="p1780012264134"></a><a name="p1780012264134"></a>抽样。</p>
</td>
</tr>
<tr id="row1480019264138"><td class="cellrowborder" valign="top" width="17.141714171417142%" headers="mcps1.2.4.1.1 "><p id="p1480062616135"><a name="p1480062616135"></a><a name="p1480062616135"></a>分层抽样</p>
</td>
<td class="cellrowborder" valign="top" width="21.632163216321633%" headers="mcps1.2.4.1.2 "><p id="p98001026101316"><a name="p98001026101316"></a><a name="p98001026101316"></a>Stratified Sampling</p>
</td>
<td class="cellrowborder" valign="top" width="61.22612261226122%" headers="mcps1.2.4.1.3 "><p id="p17323133614159"><a name="p17323133614159"></a><a name="p17323133614159"></a>分层随机抽样，又称类型随机抽样，它是先将总体各单位按一定标准分成各种类型（或层）；然后根据各类型单位数与总体单位数的比例，确定从各类型中抽取样本单位的数量；最后，按照随机原则从各类型中抽取样本。</p>
</td>
</tr>
<tr id="row1080142613137"><td class="cellrowborder" valign="top" width="17.141714171417142%" headers="mcps1.2.4.1.1 "><p id="p1580113262134"><a name="p1580113262134"></a><a name="p1580113262134"></a>对称抽样</p>
</td>
<td class="cellrowborder" valign="top" width="21.632163216321633%" headers="mcps1.2.4.1.2 "><p id="p880162661316"><a name="p880162661316"></a><a name="p880162661316"></a>Balanced Sampling</p>
</td>
<td class="cellrowborder" valign="top" width="61.22612261226122%" headers="mcps1.2.4.1.3 "><p id="p680112601318"><a name="p680112601318"></a><a name="p680112601318"></a>一些分类算法仅在每个类中的样本数大致相同时才最佳地执行。高度偏斜的数据集在许多领域中是常见的（例如，欺诈检测），因此重新采样以抵消这种不平衡可以产生更好的决策边界。</p>
</td>
</tr>
</tbody>
</table>

**表 7**  支持的机器学习算法 - 统计学

<a name="table1560264413152"></a>
<table><thead align="left"><tr id="row2603154410159"><th class="cellrowborder" valign="top" width="14.041404140414041%" id="mcps1.2.4.1.1"><p id="p17335719121813"><a name="p17335719121813"></a><a name="p17335719121813"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="24.98249824982498%" id="mcps1.2.4.1.2"><p id="p73351019111812"><a name="p73351019111812"></a><a name="p73351019111812"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="60.976097609760984%" id="mcps1.2.4.1.3"><p id="p15335131913186"><a name="p15335131913186"></a><a name="p15335131913186"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row66033448158"><td class="cellrowborder" valign="top" width="14.041404140414041%" headers="mcps1.2.4.1.1 "><p id="p46039440152"><a name="p46039440152"></a><a name="p46039440152"></a>汇总统计函数</p>
</td>
<td class="cellrowborder" valign="top" width="24.98249824982498%" headers="mcps1.2.4.1.2 "><p id="p3603174441512"><a name="p3603174441512"></a><a name="p3603174441512"></a>Summary</p>
</td>
<td class="cellrowborder" valign="top" width="60.976097609760984%" headers="mcps1.2.4.1.3 "><p id="p8603184414157"><a name="p8603184414157"></a><a name="p8603184414157"></a>生成任何数据表的摘要统计信息。</p>
</td>
</tr>
<tr id="row460324491519"><td class="cellrowborder" valign="top" width="14.041404140414041%" headers="mcps1.2.4.1.1 "><p id="p760310444157"><a name="p760310444157"></a><a name="p760310444157"></a>协方差和相关系数</p>
</td>
<td class="cellrowborder" valign="top" width="24.98249824982498%" headers="mcps1.2.4.1.2 "><p id="p186031544171516"><a name="p186031544171516"></a><a name="p186031544171516"></a>Correlation and Covariance</p>
</td>
<td class="cellrowborder" valign="top" width="60.976097609760984%" headers="mcps1.2.4.1.3 "><p id="p5603244161512"><a name="p5603244161512"></a><a name="p5603244161512"></a>描述性统计，求Pearson系数、相关系数，另一个输出协方差。了解数据从统计学上反映的量的特征，以便我们更好地认识这些将要被挖掘的数据。</p>
</td>
</tr>
<tr id="row760364412158"><td class="cellrowborder" valign="top" width="14.041404140414041%" headers="mcps1.2.4.1.1 "><p id="p460312442152"><a name="p460312442152"></a><a name="p460312442152"></a>统计频率算法</p>
</td>
<td class="cellrowborder" valign="top" width="24.98249824982498%" headers="mcps1.2.4.1.2 "><p id="p12603154411156"><a name="p12603154411156"></a><a name="p12603154411156"></a>CountMin (Cormode-Muthukrishnan)</p>
</td>
<td class="cellrowborder" valign="top" width="60.976097609760984%" headers="mcps1.2.4.1.3 "><p id="p15603114491515"><a name="p15603114491515"></a><a name="p15603114491515"></a>统计一个实时的数据流中元素出现的频率，并且准备随时回答某个元素出现的频率，不需要的精确的计数。</p>
</td>
</tr>
<tr id="row7603344191510"><td class="cellrowborder" valign="top" width="14.041404140414041%" headers="mcps1.2.4.1.1 "><p id="p14603134491511"><a name="p14603134491511"></a><a name="p14603134491511"></a>基数估计算法</p>
</td>
<td class="cellrowborder" valign="top" width="24.98249824982498%" headers="mcps1.2.4.1.2 "><p id="p166031244171517"><a name="p166031244171517"></a><a name="p166031244171517"></a>FM (Flajolet-Martin)</p>
</td>
<td class="cellrowborder" valign="top" width="60.976097609760984%" headers="mcps1.2.4.1.3 "><p id="p1760344461511"><a name="p1760344461511"></a><a name="p1760344461511"></a>获取指定列中的不同值的数量。找出这个数字集合中不重复的数字的个数。</p>
</td>
</tr>
<tr id="row2603174413154"><td class="cellrowborder" valign="top" width="14.041404140414041%" headers="mcps1.2.4.1.1 "><p id="p26039443156"><a name="p26039443156"></a><a name="p26039443156"></a>最频繁值</p>
</td>
<td class="cellrowborder" valign="top" width="24.98249824982498%" headers="mcps1.2.4.1.2 "><p id="p1603194431510"><a name="p1603194431510"></a><a name="p1603194431510"></a>MFV (Most Frequent Values)</p>
</td>
<td class="cellrowborder" valign="top" width="60.976097609760984%" headers="mcps1.2.4.1.3 "><p id="p46039446153"><a name="p46039446153"></a><a name="p46039446153"></a>计算频繁值的场景。</p>
</td>
</tr>
<tr id="row5603174416151"><td class="cellrowborder" valign="top" width="14.041404140414041%" headers="mcps1.2.4.1.1 "><p id="p12603154431512"><a name="p12603154431512"></a><a name="p12603154431512"></a>假设检验</p>
</td>
<td class="cellrowborder" valign="top" width="24.98249824982498%" headers="mcps1.2.4.1.2 "><p id="p1860434412155"><a name="p1860434412155"></a><a name="p1860434412155"></a>Hypothesis Tests</p>
</td>
<td class="cellrowborder" valign="top" width="60.976097609760984%" headers="mcps1.2.4.1.3 "><p id="p46042445154"><a name="p46042445154"></a><a name="p46042445154"></a>包含F-test、chi2-test等。</p>
</td>
</tr>
<tr id="row16194141361910"><td class="cellrowborder" valign="top" width="14.041404140414041%" headers="mcps1.2.4.1.1 "><p id="p9195613111915"><a name="p9195613111915"></a><a name="p9195613111915"></a>概率函数</p>
</td>
<td class="cellrowborder" valign="top" width="24.98249824982498%" headers="mcps1.2.4.1.2 "><p id="p191951313111920"><a name="p191951313111920"></a><a name="p191951313111920"></a>Probability Functions</p>
</td>
<td class="cellrowborder" valign="top" width="60.976097609760984%" headers="mcps1.2.4.1.3 "><p id="p16195171313199"><a name="p16195171313199"></a><a name="p16195171313199"></a>概率函数模块为各种概率分布提供累积分布、密度、质量和分位数函数。</p>
</td>
</tr>
</tbody>
</table>

**表 8**  支持的机器学习算法 - 其他算法

<a name="table910801142712"></a>
<table><thead align="left"><tr id="row01086112717"><th class="cellrowborder" valign="top" width="13.631363136313631%" id="mcps1.2.4.1.1"><p id="p6196614275"><a name="p6196614275"></a><a name="p6196614275"></a>算法名称（中文）</p>
</th>
<th class="cellrowborder" valign="top" width="18.031803180318033%" id="mcps1.2.4.1.2"><p id="p14195616278"><a name="p14195616278"></a><a name="p14195616278"></a>算法名称（英文）</p>
</th>
<th class="cellrowborder" valign="top" width="68.33683368336834%" id="mcps1.2.4.1.3"><p id="p8191569273"><a name="p8191569273"></a><a name="p8191569273"></a>应用场景</p>
</th>
</tr>
</thead>
<tbody><tr id="row181081710279"><td class="cellrowborder" valign="top" width="13.631363136313631%" headers="mcps1.2.4.1.1 "><p id="p101084117276"><a name="p101084117276"></a><a name="p101084117276"></a>k-聚类算法</p>
</td>
<td class="cellrowborder" valign="top" width="18.031803180318033%" headers="mcps1.2.4.1.2 "><p id="p71081811279"><a name="p71081811279"></a><a name="p71081811279"></a>K-means</p>
</td>
<td class="cellrowborder" valign="top" width="68.33683368336834%" headers="mcps1.2.4.1.3 "><p id="p110831182710"><a name="p110831182710"></a><a name="p110831182710"></a>聚类场景。</p>
</td>
</tr>
<tr id="row1610820182713"><td class="cellrowborder" valign="top" width="13.631363136313631%" headers="mcps1.2.4.1.1 "><p id="p410917118277"><a name="p410917118277"></a><a name="p410917118277"></a>隐含狄利克雷分布</p>
</td>
<td class="cellrowborder" valign="top" width="18.031803180318033%" headers="mcps1.2.4.1.2 "><p id="p15109171192711"><a name="p15109171192711"></a><a name="p15109171192711"></a>Latent Dirichlet Allocation (LDA)</p>
</td>
<td class="cellrowborder" valign="top" width="68.33683368336834%" headers="mcps1.2.4.1.3 "><p id="p1310915110276"><a name="p1310915110276"></a><a name="p1310915110276"></a>LDA 在主题模型中占有非常重要的地位，常用来文本分类。</p>
</td>
</tr>
<tr id="row7109411278"><td class="cellrowborder" valign="top" width="13.631363136313631%" headers="mcps1.2.4.1.1 "><p id="p910919132719"><a name="p910919132719"></a><a name="p910919132719"></a>关联规则算法</p>
</td>
<td class="cellrowborder" valign="top" width="18.031803180318033%" headers="mcps1.2.4.1.2 "><p id="p1510918116272"><a name="p1510918116272"></a><a name="p1510918116272"></a>Apriori Algorithm</p>
</td>
<td class="cellrowborder" valign="top" width="68.33683368336834%" headers="mcps1.2.4.1.3 "><p id="p10109514274"><a name="p10109514274"></a><a name="p10109514274"></a>关联规则算法，关联规则挖掘的目标是发现数据项集之间的关联关系。比如经典的“啤酒和尿布”。</p>
</td>
</tr>
</tbody>
</table>
